{
  "version": 4,
  "terraform_version": "1.13.1",
  "serial": 340,
  "lineage": "0ff28e8f-3c64-776b-9110-b5ee7523ec05",
  "outputs": {
    "auto_initialize_enabled": {
      "value": true,
      "type": "bool"
    },
    "chart_version": {
      "value": "0.31.0",
      "type": "string"
    },
    "get_root_token_command": {
      "value": "kubectl get secret vault-unseal-keys -n vault -o jsonpath='{.data.root_token}' | base64 -d",
      "type": "string"
    },
    "get_unseal_keys_command": {
      "value": "kubectl get secret vault-unseal-keys -n vault -o jsonpath='{.data.unseal_keys_b64}' | base64 -d | jq",
      "type": "string"
    },
    "ingress_host": {
      "value": "vault.local",
      "type": "string"
    },
    "ingress_url": {
      "value": "http://vault.local",
      "type": "string"
    },
    "init_command": {
      "value": "kubectl exec -n vault vault-0 -- vault operator init -key-shares=5 -key-threshold=3 -format=json",
      "type": "string"
    },
    "init_job_logs_command": {
      "value": "kubectl logs -n vault job/vault-auto-init",
      "type": "string"
    },
    "init_job_status_command": {
      "value": "kubectl get job vault-auto-init -n vault",
      "type": "string"
    },
    "init_secret_name": {
      "value": "vault-unseal-keys",
      "type": "string"
    },
    "manual_unseal_script": {
      "value": "./scripts/k8s-unseal-vault.sh",
      "type": "string"
    },
    "namespace": {
      "value": "vault",
      "type": "string"
    },
    "port_forward_command": {
      "value": "kubectl port-forward -n vault svc/vault 8200:8200",
      "type": "string"
    },
    "raft_peers_command": {
      "value": "kubectl exec -n vault vault-0 -- vault operator raft list-peers",
      "type": "string"
    },
    "release_metadata": {
      "value": {
        "app_version": "1.20.4",
        "chart": "vault",
        "first_deployed": 1760926962,
        "last_deployed": 1760926962,
        "name": "vault",
        "namespace": "vault",
        "notes": "\nThank you for installing HashiCorp Vault!\n\nNow that you have deployed Vault, you should look over the docs on using\nVault with Kubernetes available here:\n\nhttps://developer.hashicorp.com/vault/docs\n\n\nYour release is named vault. To learn more about the release, try:\n\n  $ helm status vault\n  $ helm get manifest vault\n\n",
        "revision": 1,
        "values": "{\"global\":{\"enabled\":true,\"tlsDisable\":true},\"injector\":{\"agentImage\":{\"repository\":\"hashicorp/vault\",\"tag\":\"1.20.4\"},\"enabled\":true,\"image\":{\"repository\":\"hashicorp/vault-k8s\",\"tag\":\"1.7.0\"}},\"server\":{\"affinity\":\"\\\"podAntiAffinity\\\":\\n  \\\"requiredDuringSchedulingIgnoredDuringExecution\\\":\\n  - \\\"labelSelector\\\":\\n      \\\"matchLabels\\\":\\n        \\\"app.kubernetes.io/instance\\\": \\\"vault\\\"\\n        \\\"app.kubernetes.io/name\\\": \\\"vault\\\"\\n        \\\"component\\\": \\\"server\\\"\\n    \\\"topologyKey\\\": \\\"kubernetes.io/hostname\\\"\\n\",\"annotations\":{},\"auditStorage\":{\"accessMode\":\"ReadWriteOnce\",\"enabled\":false,\"size\":\"10Gi\",\"storageClass\":null},\"authDelegator\":{\"enabled\":true},\"dataStorage\":{\"accessMode\":\"ReadWriteOnce\",\"enabled\":true,\"size\":\"10Gi\",\"storageClass\":null},\"extraLabels\":{},\"ha\":{\"disruptionBudget\":{\"enabled\":true,\"maxUnavailable\":1},\"enabled\":true,\"raft\":{\"config\":\"ui = true\\n\\nlistener \\\"tcp\\\" {\\n  address     = \\\"[::]:8200\\\"\\n  cluster_address = \\\"[::]:8201\\\"\\n  tls_disable = \\\"1\\\"\\n}\\n\\nstorage \\\"raft\\\" {\\n  path = \\\"/vault/data\\\"\\n\\n                retry_join {\\n    leader_api_addr = \\\"http://vault-0.vault-internal:8200\\\"\\n  }\\n                retry_join {\\n    leader_api_addr = \\\"http://vault-1.vault-internal:8200\\\"\\n  }\\n                retry_join {\\n    leader_api_addr = \\\"http://vault-2.vault-internal:8200\\\"\\n  }\\n  \\n  autopilot {\\n    cleanup_dead_servers      = true\\n    last_contact_threshold    = \\\"10s\\\"\\n    max_trailing_logs         = 1000\\n    server_stabilization_time = \\\"10s\\\"\\n    min_quorum                = 2\\n    disable_upgrade_migration = false\\n  }\\n}\\n\\nservice_registration \\\"kubernetes\\\" {}\\n\\nlog_level  = \\\"info\\\"\\nlog_format = \\\"json\\\"\\n\",\"enabled\":true,\"setNodeId\":true},\"replicas\":3},\"image\":{\"repository\":\"hashicorp/vault\",\"tag\":\"1.20.4\"},\"logFormat\":\"json\",\"logLevel\":\"info\",\"resources\":{\"limits\":{\"cpu\":\"500m\",\"memory\":\"512Mi\"},\"requests\":{\"cpu\":\"250m\",\"memory\":\"256Mi\"}},\"service\":{\"active\":{\"enabled\":true},\"enabled\":true,\"standby\":{\"enabled\":true}},\"serviceAccount\":{\"create\":true,\"name\":\"vault-sa\",\"serviceDiscovery\":{\"enabled\":true}},\"standalone\":{\"config\":\"ui = true\\n\\nlistener \\\"tcp\\\" {\\n  address     = \\\"[::]:8200\\\"\\n  cluster_address = \\\"[::]:8201\\\"\\n  tls_disable = \\\"1\\\"\\n}\\n\\nstorage \\\"file\\\" {\\n  path = \\\"/vault/data\\\"\\n}\\n\\nlog_level  = \\\"info\\\"\\nlog_format = \\\"json\\\"\\n\",\"enabled\":false}},\"serverTelemetry\":{\"serviceMonitor\":{\"enabled\":false}},\"ui\":{\"enabled\":true,\"externalPort\":8200,\"publishNotReadyAddresses\":true,\"serviceType\":\"ClusterIP\"}}",
        "version": "0.31.0"
      },
      "type": [
        "object",
        {
          "app_version": "string",
          "chart": "string",
          "first_deployed": "number",
          "last_deployed": "number",
          "name": "string",
          "namespace": "string",
          "notes": "string",
          "revision": "number",
          "values": "string",
          "version": "string"
        }
      ],
      "sensitive": true
    },
    "release_name": {
      "value": "vault",
      "type": "string"
    },
    "release_status": {
      "value": "deployed",
      "type": "string"
    },
    "replicas": {
      "value": 3,
      "type": "number"
    },
    "status_command": {
      "value": "kubectl exec -n vault vault-0 -- vault status",
      "type": "string"
    },
    "unseal_command_example": {
      "value": "kubectl exec -n vault vault-0 -- vault operator unseal \u003cunseal-key\u003e",
      "type": "string"
    },
    "vault_active_service_name": {
      "value": "vault-active",
      "type": "string"
    },
    "vault_addr": {
      "value": "http://vault.vault.svc.cluster.local:8200",
      "type": "string"
    },
    "vault_cluster_port": {
      "value": 8201,
      "type": "number"
    },
    "vault_port": {
      "value": 8200,
      "type": "number"
    },
    "vault_service_fqdn": {
      "value": "vault.vault.svc.cluster.local",
      "type": "string"
    },
    "vault_service_name": {
      "value": "vault",
      "type": "string"
    },
    "vault_standby_service_name": {
      "value": "vault-standby",
      "type": "string"
    },
    "vault_ui_service_name": {
      "value": "vault-ui",
      "type": "string"
    }
  },
  "resources": [
    {
      "mode": "managed",
      "type": "helm_release",
      "name": "vault",
      "provider": "provider[\"registry.terraform.io/hashicorp/helm\"]",
      "instances": [
        {
          "schema_version": 2,
          "attributes": {
            "atomic": false,
            "chart": "vault",
            "cleanup_on_fail": false,
            "create_namespace": false,
            "dependency_update": false,
            "description": null,
            "devel": null,
            "disable_crd_hooks": false,
            "disable_openapi_validation": false,
            "disable_webhooks": false,
            "force_update": false,
            "id": "vault",
            "keyring": null,
            "lint": false,
            "manifest": null,
            "max_history": 0,
            "metadata": {
              "app_version": "1.20.4",
              "chart": "vault",
              "first_deployed": 1760926962,
              "last_deployed": 1760926962,
              "name": "vault",
              "namespace": "vault",
              "notes": "\nThank you for installing HashiCorp Vault!\n\nNow that you have deployed Vault, you should look over the docs on using\nVault with Kubernetes available here:\n\nhttps://developer.hashicorp.com/vault/docs\n\n\nYour release is named vault. To learn more about the release, try:\n\n  $ helm status vault\n  $ helm get manifest vault\n\n",
              "revision": 1,
              "values": "{\"global\":{\"enabled\":true,\"tlsDisable\":true},\"injector\":{\"agentImage\":{\"repository\":\"hashicorp/vault\",\"tag\":\"1.20.4\"},\"enabled\":true,\"image\":{\"repository\":\"hashicorp/vault-k8s\",\"tag\":\"1.7.0\"}},\"server\":{\"affinity\":\"\\\"podAntiAffinity\\\":\\n  \\\"requiredDuringSchedulingIgnoredDuringExecution\\\":\\n  - \\\"labelSelector\\\":\\n      \\\"matchLabels\\\":\\n        \\\"app.kubernetes.io/instance\\\": \\\"vault\\\"\\n        \\\"app.kubernetes.io/name\\\": \\\"vault\\\"\\n        \\\"component\\\": \\\"server\\\"\\n    \\\"topologyKey\\\": \\\"kubernetes.io/hostname\\\"\\n\",\"annotations\":{},\"auditStorage\":{\"accessMode\":\"ReadWriteOnce\",\"enabled\":false,\"size\":\"10Gi\",\"storageClass\":null},\"authDelegator\":{\"enabled\":true},\"dataStorage\":{\"accessMode\":\"ReadWriteOnce\",\"enabled\":true,\"size\":\"10Gi\",\"storageClass\":null},\"extraLabels\":{},\"ha\":{\"disruptionBudget\":{\"enabled\":true,\"maxUnavailable\":1},\"enabled\":true,\"raft\":{\"config\":\"ui = true\\n\\nlistener \\\"tcp\\\" {\\n  address     = \\\"[::]:8200\\\"\\n  cluster_address = \\\"[::]:8201\\\"\\n  tls_disable = \\\"1\\\"\\n}\\n\\nstorage \\\"raft\\\" {\\n  path = \\\"/vault/data\\\"\\n\\n                retry_join {\\n    leader_api_addr = \\\"http://vault-0.vault-internal:8200\\\"\\n  }\\n                retry_join {\\n    leader_api_addr = \\\"http://vault-1.vault-internal:8200\\\"\\n  }\\n                retry_join {\\n    leader_api_addr = \\\"http://vault-2.vault-internal:8200\\\"\\n  }\\n  \\n  autopilot {\\n    cleanup_dead_servers      = true\\n    last_contact_threshold    = \\\"10s\\\"\\n    max_trailing_logs         = 1000\\n    server_stabilization_time = \\\"10s\\\"\\n    min_quorum                = 2\\n    disable_upgrade_migration = false\\n  }\\n}\\n\\nservice_registration \\\"kubernetes\\\" {}\\n\\nlog_level  = \\\"info\\\"\\nlog_format = \\\"json\\\"\\n\",\"enabled\":true,\"setNodeId\":true},\"replicas\":3},\"image\":{\"repository\":\"hashicorp/vault\",\"tag\":\"1.20.4\"},\"logFormat\":\"json\",\"logLevel\":\"info\",\"resources\":{\"limits\":{\"cpu\":\"500m\",\"memory\":\"512Mi\"},\"requests\":{\"cpu\":\"250m\",\"memory\":\"256Mi\"}},\"service\":{\"active\":{\"enabled\":true},\"enabled\":true,\"standby\":{\"enabled\":true}},\"serviceAccount\":{\"create\":true,\"name\":\"vault-sa\",\"serviceDiscovery\":{\"enabled\":true}},\"standalone\":{\"config\":\"ui = true\\n\\nlistener \\\"tcp\\\" {\\n  address     = \\\"[::]:8200\\\"\\n  cluster_address = \\\"[::]:8201\\\"\\n  tls_disable = \\\"1\\\"\\n}\\n\\nstorage \\\"file\\\" {\\n  path = \\\"/vault/data\\\"\\n}\\n\\nlog_level  = \\\"info\\\"\\nlog_format = \\\"json\\\"\\n\",\"enabled\":false}},\"serverTelemetry\":{\"serviceMonitor\":{\"enabled\":false}},\"ui\":{\"enabled\":true,\"externalPort\":8200,\"publishNotReadyAddresses\":true,\"serviceType\":\"ClusterIP\"}}",
              "version": "0.31.0"
            },
            "name": "vault",
            "namespace": "vault",
            "pass_credentials": false,
            "postrender": null,
            "recreate_pods": false,
            "render_subchart_notes": true,
            "replace": false,
            "repository": "https://helm.releases.hashicorp.com",
            "repository_ca_file": null,
            "repository_cert_file": null,
            "repository_key_file": null,
            "repository_password": null,
            "repository_username": null,
            "reset_values": false,
            "reuse_values": false,
            "set": null,
            "set_list": null,
            "set_sensitive": null,
            "set_wo": null,
            "set_wo_revision": null,
            "skip_crds": false,
            "status": "deployed",
            "timeout": 600,
            "values": [
              "\"global\":\n  \"enabled\": true\n  \"tlsDisable\": true\n\"injector\":\n  \"agentImage\":\n    \"repository\": \"hashicorp/vault\"\n    \"tag\": \"1.20.4\"\n  \"enabled\": true\n  \"image\":\n    \"repository\": \"hashicorp/vault-k8s\"\n    \"tag\": \"1.7.0\"\n\"server\":\n  \"affinity\": |\n    \"podAntiAffinity\":\n      \"requiredDuringSchedulingIgnoredDuringExecution\":\n      - \"labelSelector\":\n          \"matchLabels\":\n            \"app.kubernetes.io/instance\": \"vault\"\n            \"app.kubernetes.io/name\": \"vault\"\n            \"component\": \"server\"\n        \"topologyKey\": \"kubernetes.io/hostname\"\n  \"annotations\": {}\n  \"auditStorage\":\n    \"accessMode\": \"ReadWriteOnce\"\n    \"enabled\": false\n    \"size\": \"10Gi\"\n    \"storageClass\": null\n  \"authDelegator\":\n    \"enabled\": true\n  \"dataStorage\":\n    \"accessMode\": \"ReadWriteOnce\"\n    \"enabled\": true\n    \"size\": \"10Gi\"\n    \"storageClass\": null\n  \"extraLabels\": {}\n  \"ha\":\n    \"disruptionBudget\":\n      \"enabled\": true\n      \"maxUnavailable\": 1\n    \"enabled\": true\n    \"raft\":\n      \"config\": \"ui = true\\n\\nlistener \\\"tcp\\\" {\\n  address     = \\\"[::]:8200\\\"\\n\n        \\ cluster_address = \\\"[::]:8201\\\"\\n  tls_disable = \\\"1\\\"\\n}\\n\\nstorage \\\"raft\\\"\n        {\\n  path = \\\"/vault/data\\\"\\n\\n                retry_join {\\n    leader_api_addr\n        = \\\"http://vault-0.vault-internal:8200\\\"\\n  }\\n                retry_join\n        {\\n    leader_api_addr = \\\"http://vault-1.vault-internal:8200\\\"\\n  }\\n                retry_join\n        {\\n    leader_api_addr = \\\"http://vault-2.vault-internal:8200\\\"\\n  }\\n  \\n\n        \\ autopilot {\\n    cleanup_dead_servers      = true\\n    last_contact_threshold\n        \\   = \\\"10s\\\"\\n    max_trailing_logs         = 1000\\n    server_stabilization_time\n        = \\\"10s\\\"\\n    min_quorum                = 2\\n    disable_upgrade_migration\n        = false\\n  }\\n}\\n\\nservice_registration \\\"kubernetes\\\" {}\\n\\nlog_level  =\n        \\\"info\\\"\\nlog_format = \\\"json\\\"\\n\"\n      \"enabled\": true\n      \"setNodeId\": true\n    \"replicas\": 3\n  \"image\":\n    \"repository\": \"hashicorp/vault\"\n    \"tag\": \"1.20.4\"\n  \"logFormat\": \"json\"\n  \"logLevel\": \"info\"\n  \"resources\":\n    \"limits\":\n      \"cpu\": \"500m\"\n      \"memory\": \"512Mi\"\n    \"requests\":\n      \"cpu\": \"250m\"\n      \"memory\": \"256Mi\"\n  \"service\":\n    \"active\":\n      \"enabled\": true\n    \"enabled\": true\n    \"standby\":\n      \"enabled\": true\n  \"serviceAccount\":\n    \"create\": true\n    \"name\": \"vault-sa\"\n    \"serviceDiscovery\":\n      \"enabled\": true\n  \"standalone\":\n    \"config\": |\n      ui = true\n\n      listener \"tcp\" {\n        address     = \"[::]:8200\"\n        cluster_address = \"[::]:8201\"\n        tls_disable = \"1\"\n      }\n\n      storage \"file\" {\n        path = \"/vault/data\"\n      }\n\n      log_level  = \"info\"\n      log_format = \"json\"\n    \"enabled\": false\n\"serverTelemetry\":\n  \"serviceMonitor\":\n    \"enabled\": false\n\"ui\":\n  \"enabled\": true\n  \"externalPort\": 8200\n  \"publishNotReadyAddresses\": true\n  \"serviceType\": \"ClusterIP\"\n"
            ],
            "verify": false,
            "version": "0.31.0",
            "wait": true,
            "wait_for_jobs": false
          },
          "sensitive_attributes": [
            [
              {
                "type": "get_attr",
                "value": "repository_password"
              }
            ]
          ],
          "identity_schema_version": 0,
          "identity": {
            "namespace": "vault",
            "release_name": "vault"
          },
          "dependencies": [
            "kubernetes_namespace.vault"
          ]
        }
      ]
    },
    {
      "mode": "managed",
      "type": "kubernetes_config_map",
      "name": "vault_init_scripts",
      "provider": "provider[\"registry.terraform.io/hashicorp/kubernetes\"]",
      "instances": [
        {
          "index_key": 0,
          "schema_version": 0,
          "attributes": {
            "binary_data": null,
            "data": {
              "init-vault.sh": "#!/usr/bin/env bash\n# Vault Auto-Initialization Script for Kubernetes\n# This script initializes a Vault HA cluster and stores unseal keys in Kubernetes Secret\n# Designed to run in a Kubernetes Job with proper RBAC permissions\n\nset -euo pipefail\n\n# Configuration from environment variables\nNAMESPACE=\"${VAULT_NAMESPACE:-vault}\"\nRELEASE_NAME=\"${VAULT_RELEASE:-vault}\"\nKEY_SHARES=\"${VAULT_KEY_SHARES:-5}\"\nKEY_THRESHOLD=\"${VAULT_KEY_THRESHOLD:-3}\"\nSECRET_NAME=\"${VAULT_SECRET_NAME:-vault-unseal-keys}\"\nAUTO_UNSEAL=\"${AUTO_UNSEAL:-true}\"\nMAX_RETRY=\"${MAX_RETRY_ATTEMPTS:-5}\"\nOPERATION_TIMEOUT=\"${OPERATION_TIMEOUT:-300}\"\nDEBUG=\"${DEBUG:-false}\"\n\n# Color definitions for output\nreadonly RED='\\033[0;31m'\nreadonly GREEN='\\033[0;32m'\nreadonly YELLOW='\\033[1;33m'\nreadonly BLUE='\\033[0;34m'\nreadonly NC='\\033[0m' # No Color\n\n# Logging functions\nlog_with_timestamp() {\n    local level=$1\n    shift\n    echo -e \"[$(date +'%Y-%m-%d %H:%M:%S')] [${level}] $*\"\n}\n\nprint_info() {\n    log_with_timestamp \"${BLUE}INFO${NC}\" \"$1\"\n}\n\nprint_success() {\n    log_with_timestamp \"${GREEN}SUCCESS${NC}\" \"$1\"\n}\n\nprint_warning() {\n    log_with_timestamp \"${YELLOW}WARNING${NC}\" \"$1\"\n}\n\nprint_error() {\n    log_with_timestamp \"${RED}ERROR${NC}\" \"$1\"\n}\n\nprint_debug() {\n    if [[ \"${DEBUG}\" == \"true\" ]]; then\n        log_with_timestamp \"DEBUG\" \"$1\"\n    fi\n}\n\n# Retry helper function with exponential backoff\nretry_command() {\n    local max_attempts=$1\n    shift\n    local cmd=(\"$@\")\n    local attempt=1\n    local delay=2\n\n    while [ $attempt -le $max_attempts ]; do\n        print_debug \"Attempt $attempt/$max_attempts: ${cmd[*]}\"\n\n        if \"${cmd[@]}\"; then\n            return 0\n        fi\n\n        if [ $attempt -lt $max_attempts ]; then\n            print_warning \"Command failed, retrying in ${delay}s... (attempt $attempt/$max_attempts)\"\n            sleep $delay\n            delay=$((delay * 2))  # Exponential backoff\n            attempt=$((attempt + 1))\n        else\n            print_error \"Command failed after $max_attempts attempts\"\n            return 1\n        fi\n    done\n}\n\n# Cleanup function for error handling\ncleanup_on_error() {\n    local exit_code=$?\n    if [ $exit_code -ne 0 ]; then\n        print_error \"Script failed with exit code: $exit_code\"\n        print_info \"Check logs above for details\"\n    fi\n}\n\ntrap cleanup_on_error EXIT\n\n# Validate environment variables\nvalidate_environment() {\n    print_info \"Validating environment variables...\"\n\n    local required_vars=(\"NAMESPACE\" \"RELEASE_NAME\" \"SECRET_NAME\" \"KEY_SHARES\" \"KEY_THRESHOLD\")\n    local missing_vars=()\n\n    for var in \"${required_vars[@]}\"; do\n        if [[ -z \"${!var:-}\" ]]; then\n            missing_vars+=(\"$var\")\n        fi\n    done\n\n    if [ ${#missing_vars[@]} -gt 0 ]; then\n        print_error \"Missing required environment variables: ${missing_vars[*]}\"\n        exit 1\n    fi\n\n    # Validate numeric values\n    if ! [[ \"$KEY_SHARES\" =~ ^[0-9]+$ ]] || [ \"$KEY_SHARES\" -lt 1 ]; then\n        print_error \"KEY_SHARES must be a positive integer\"\n        exit 1\n    fi\n\n    if ! [[ \"$KEY_THRESHOLD\" =~ ^[0-9]+$ ]] || [ \"$KEY_THRESHOLD\" -lt 1 ]; then\n        print_error \"KEY_THRESHOLD must be a positive integer\"\n        exit 1\n    fi\n\n    if [ \"$KEY_THRESHOLD\" -gt \"$KEY_SHARES\" ]; then\n        print_error \"KEY_THRESHOLD ($KEY_THRESHOLD) cannot be greater than KEY_SHARES ($KEY_SHARES)\"\n        exit 1\n    fi\n\n    print_success \"Environment validation passed\"\n}\n\n# Configure kubectl for in-cluster access\nconfigure_kubectl() {\n    print_info \"Configuring kubectl for in-cluster access...\"\n\n    # ServiceAccount token and CA certificate are mounted by Kubernetes\n    local token_file=\"/var/run/secrets/kubernetes.io/serviceaccount/token\"\n    local ca_file=\"/var/run/secrets/kubernetes.io/serviceaccount/ca.crt\"\n    local k8s_server=\"https://kubernetes.default.svc\"\n\n    # Verify ServiceAccount files exist\n    if [[ ! -f \"${token_file}\" ]]; then\n        print_error \"ServiceAccount token not found at ${token_file}\"\n        exit 1\n    fi\n\n    if [[ ! -f \"${ca_file}\" ]]; then\n        print_error \"ServiceAccount CA certificate not found at ${ca_file}\"\n        exit 1\n    fi\n\n    # Configure kubectl cluster\n    if ! kubectl config set-cluster kubernetes \\\n        --server=\"${k8s_server}\" \\\n        --certificate-authority=\"${ca_file}\" \u0026\u003e/dev/null; then\n        print_error \"Failed to configure kubectl cluster\"\n        exit 1\n    fi\n\n    # Configure kubectl credentials\n    if ! kubectl config set-credentials serviceaccount \\\n        --token=\"$(cat \"${token_file}\")\" \u0026\u003e/dev/null; then\n        print_error \"Failed to configure kubectl credentials\"\n        exit 1\n    fi\n\n    # Configure kubectl context\n    if ! kubectl config set-context default \\\n        --cluster=kubernetes \\\n        --user=serviceaccount \\\n        --namespace=\"${NAMESPACE}\" \u0026\u003e/dev/null; then\n        print_error \"Failed to configure kubectl context\"\n        exit 1\n    fi\n\n    # Use the context\n    if ! kubectl config use-context default \u0026\u003e/dev/null; then\n        print_error \"Failed to use kubectl context\"\n        exit 1\n    fi\n\n    print_success \"kubectl configured successfully for in-cluster access\"\n}\n\n# Check prerequisites\ncheck_prerequisites() {\n    print_info \"Checking prerequisites...\"\n\n    if ! command -v kubectl \u0026\u003e /dev/null; then\n        print_error \"kubectl is not installed or not in PATH\"\n        exit 1\n    fi\n\n    if ! command -v jq \u0026\u003e /dev/null; then\n        print_error \"jq is not installed or not in PATH\"\n        exit 1\n    fi\n\n    # Verify kubectl can access cluster (list pods in namespace)\n    if ! kubectl get pods -n \"${NAMESPACE}\" \u0026\u003e /dev/null; then\n        print_error \"Cannot connect to Kubernetes cluster or access namespace '${NAMESPACE}'\"\n        exit 1\n    fi\n\n    # Verify RBAC permissions\n    print_debug \"Verifying RBAC permissions...\"\n    if ! kubectl auth can-i create pods/exec -n \"${NAMESPACE}\" \u0026\u003e /dev/null; then\n        print_warning \"May not have permission to exec into pods\"\n    fi\n\n    print_success \"Prerequisites check passed\"\n}\n\n# Check if Kubernetes Secret exists\nsecret_exists() {\n    retry_command 3 kubectl get secret \"${SECRET_NAME}\" -n \"${NAMESPACE}\" \u0026\u003e/dev/null\n}\n\n# Check if Vault is already initialized\nis_vault_initialized() {\n    local leader_pod=\"${RELEASE_NAME}-0\"\n\n    print_debug \"Checking if Vault is initialized on ${leader_pod}...\"\n\n    local initialized\n    initialized=$(kubectl -n \"${NAMESPACE}\" exec \"${leader_pod}\" -- \\\n        vault status -format=json 2\u003e/dev/null | jq -r '.initialized' || echo \"false\")\n\n    print_debug \"Vault initialized status: ${initialized}\"\n\n    if [[ \"${initialized}\" == \"true\" ]]; then\n        return 0  # Already initialized\n    else\n        return 1  # Not initialized\n    fi\n}\n\n# Wait for pod to be ready\nwait_for_pod() {\n    local pod=$1\n    local max_wait=${OPERATION_TIMEOUT}\n    local elapsed=0\n\n    print_info \"Waiting for pod ${pod} to be ready (timeout: ${max_wait}s)...\"\n\n    while [ $elapsed -lt $max_wait ]; do\n        if kubectl -n \"${NAMESPACE}\" get pod \"${pod}\" \u0026\u003e /dev/null; then\n            local status\n            status=$(kubectl -n \"${NAMESPACE}\" get pod \"${pod}\" -o jsonpath='{.status.phase}')\n\n            if [[ \"${status}\" == \"Running\" ]]; then\n                # Check if Vault process is responsive (accepts commands even when sealed/uninitialized)\n                # Capture output first to avoid pipefail issues with kubectl exit codes\n                local vault_status\n                vault_status=$(kubectl -n \"${NAMESPACE}\" exec \"${pod}\" -- vault status 2\u003e\u00261 || true)\n\n                # Check if we got valid output from vault\n                if echo \"${vault_status}\" | grep -q -e \"Seal Type\" -e \"Sealed\" -e \"Initialized\"; then\n                    # Vault is responsive (could be sealed, unsealed, initialized, or uninitialized)\n                    print_success \"Pod ${pod} is ready (Vault process is responsive)\"\n                    return 0\n                fi\n            fi\n        fi\n\n        sleep 5\n        elapsed=$((elapsed + 5))\n\n        if [ $((elapsed % 30)) -eq 0 ]; then\n            print_debug \"Still waiting for ${pod}... (${elapsed}s/${max_wait}s)\"\n        fi\n    done\n\n    print_error \"Pod ${pod} failed to become ready after ${max_wait}s\"\n    return 1\n}\n\n# Get replica count\nget_replica_count() {\n    local replicas\n    replicas=$(kubectl -n \"${NAMESPACE}\" get statefulset \"${RELEASE_NAME}\" \\\n        -o jsonpath='{.spec.replicas}' 2\u003e/dev/null || echo \"1\")\n    echo \"${replicas}\"\n}\n\n# Create Kubernetes Secret with init data\ncreate_vault_secret() {\n    local init_data=$1\n\n    print_info \"Creating Kubernetes Secret: ${SECRET_NAME}\"\n\n    # Extract data from init output\n    local root_token\n    local unseal_keys_b64\n    local unseal_keys_hex\n\n    root_token=$(echo \"${init_data}\" | jq -r '.root_token')\n    unseal_keys_b64=$(echo \"${init_data}\" | jq -c '.unseal_keys_b64')\n    unseal_keys_hex=$(echo \"${init_data}\" | jq -c '.unseal_keys_hex')\n\n    if [[ -z \"${root_token}\" || \"${root_token}\" == \"null\" ]]; then\n        print_error \"Failed to extract root token from init output\"\n        return 1\n    fi\n\n    # Create secret with all necessary data\n    if kubectl create secret generic \"${SECRET_NAME}\" \\\n        -n \"${NAMESPACE}\" \\\n        --from-literal=root_token=\"${root_token}\" \\\n        --from-literal=unseal_keys_b64=\"${unseal_keys_b64}\" \\\n        --from-literal=unseal_keys_hex=\"${unseal_keys_hex}\" \\\n        --from-literal=key_shares=\"${KEY_SHARES}\" \\\n        --from-literal=key_threshold=\"${KEY_THRESHOLD}\" \\\n        --from-literal=initialized_at=\"$(date -Iseconds)\" \\\n        --dry-run=client -o yaml | kubectl apply -f - \u0026\u003e /dev/null; then\n        print_success \"Secret ${SECRET_NAME} created successfully\"\n        return 0\n    else\n        print_error \"Failed to create secret ${SECRET_NAME}\"\n        return 1\n    fi\n}\n\n# Initialize Vault cluster\ninitialize_vault() {\n    local leader_pod=\"${RELEASE_NAME}-0\"\n\n    print_info \"=== Phase 1: Initializing Vault cluster ===\"\n    print_info \"Leader pod: ${leader_pod}\"\n    print_info \"Key shares: ${KEY_SHARES}, threshold: ${KEY_THRESHOLD}\"\n\n    # Wait for leader pod to be ready\n    if ! wait_for_pod \"${leader_pod}\"; then\n        print_error \"Leader pod is not ready, cannot initialize\"\n        exit 1\n    fi\n\n    # Perform initialization\n    print_info \"Initializing Vault...\"\n\n    local init_output\n    if init_output=$(kubectl -n \"${NAMESPACE}\" exec \"${leader_pod}\" -- \\\n        vault operator init \\\n        -key-shares=\"${KEY_SHARES}\" \\\n        -key-threshold=\"${KEY_THRESHOLD}\" \\\n        -format=json 2\u003e\u00261); then\n\n        print_success \"Vault initialized successfully\"\n        print_debug \"Init output length: ${#init_output} characters\"\n\n        # Store in Kubernetes Secret\n        if create_vault_secret \"${init_output}\"; then\n            print_success \"Unseal keys and root token stored in Secret: ${SECRET_NAME}\"\n        else\n            print_error \"Failed to store init data in Secret\"\n            print_error \"Init output: ${init_output}\"\n            exit 1\n        fi\n\n        # Export for unsealing\n        export INIT_OUTPUT=\"${init_output}\"\n    else\n        print_error \"Failed to initialize Vault\"\n        print_error \"Error output: ${init_output}\"\n        exit 1\n    fi\n}\n\n# Unseal a single pod\nunseal_pod() {\n    local pod=$1\n    local init_data=$2\n\n    print_info \"Unsealing pod: ${pod}...\"\n\n    # Check if pod exists and is running\n    local pod_status\n    pod_status=$(kubectl -n \"${NAMESPACE}\" get pod \"${pod}\" -o jsonpath='{.status.phase}' 2\u003e/dev/null || echo \"NotFound\")\n\n    if [[ \"${pod_status}\" != \"Running\" ]]; then\n        print_warning \"Pod ${pod} is not running (status: ${pod_status}), skipping\"\n        return 1\n    fi\n\n    # Check if already unsealed\n    local sealed\n    sealed=$(kubectl -n \"${NAMESPACE}\" exec \"${pod}\" -- \\\n        vault status -format=json 2\u003e/dev/null | jq -r '.sealed' || echo \"true\")\n\n    if [[ \"${sealed}\" == \"false\" ]]; then\n        print_info \"Pod ${pod} is already unsealed\"\n        return 0\n    fi\n\n    # Extract unseal keys\n    local keys=()\n    for ((i=0; i\u003cKEY_THRESHOLD; i++)); do\n        local key\n        key=$(echo \"${init_data}\" | jq -r \".unseal_keys_b64[${i}]\")\n        if [[ -z \"${key}\" || \"${key}\" == \"null\" ]]; then\n            print_error \"Invalid or missing unseal key at index ${i}\"\n            return 1\n        fi\n        keys+=(\"${key}\")\n    done\n\n    # Apply unseal keys with retry\n    for key in \"${keys[@]}\"; do\n        if ! retry_command 3 kubectl -n \"${NAMESPACE}\" exec \"${pod}\" -- \\\n            vault operator unseal \"${key}\" \u003e /dev/null 2\u003e\u00261; then\n            print_error \"Failed to apply unseal key to ${pod}\"\n            return 1\n        fi\n    done\n\n    # Verify unsealed\n    sealed=$(kubectl -n \"${NAMESPACE}\" exec \"${pod}\" -- \\\n        vault status -format=json 2\u003e/dev/null | jq -r '.sealed' || echo \"true\")\n\n    if [[ \"${sealed}\" == \"false\" ]]; then\n        print_success \"Pod ${pod} unsealed successfully\"\n        return 0\n    else\n        print_error \"Pod ${pod} still sealed after unseal attempt\"\n        return 1\n    fi\n}\n\n# Join follower node to Raft cluster\njoin_follower_to_raft() {\n    local follower_pod=$1\n    local leader_pod=\"${RELEASE_NAME}-0\"\n\n    print_info \"Joining ${follower_pod} to Raft cluster...\"\n\n    # Skip if this is the leader pod\n    if [[ \"${follower_pod}\" == \"${leader_pod}\" ]]; then\n        print_debug \"${follower_pod} is the leader, skipping join\"\n        return 0\n    fi\n\n    # Check if already a member\n    local is_member\n    is_member=$(kubectl -n \"${NAMESPACE}\" exec \"${follower_pod}\" -- \\\n        vault status -format=json 2\u003e/dev/null | jq -r '.raft_joined' || echo \"false\")\n\n    if [[ \"${is_member}\" == \"true\" ]]; then\n        print_info \"${follower_pod} is already a member of the Raft cluster\"\n        return 0\n    fi\n\n    # Get leader address\n    local leader_addr=\"http://${leader_pod}.${RELEASE_NAME}-internal:8200\"\n\n    # Attempt to join the Raft cluster (with retry for timing issues)\n    local join_output\n    if join_output=$(kubectl -n \"${NAMESPACE}\" exec \"${follower_pod}\" -- \\\n        vault operator raft join \"${leader_addr}\" 2\u003e\u00261); then\n        print_success \"${follower_pod} joined Raft cluster successfully\"\n\n        # Wait for cluster sync\n        print_debug \"Waiting for cluster synchronization...\"\n        sleep 2\n        return 0\n    else\n        # Check if error is due to already being a member\n        if echo \"${join_output}\" | grep -q \"node already part of cluster\\|already joined\"; then\n            print_info \"${follower_pod} is already a member of the Raft cluster\"\n            return 0\n        else\n            print_warning \"Failed to join ${follower_pod} to Raft cluster\"\n            print_debug \"Join output: ${join_output}\"\n            return 1\n        fi\n    fi\n}\n\n# Unseal all pods in the cluster\nunseal_cluster() {\n    local init_data=$1\n    local replicas\n    replicas=$(get_replica_count)\n\n    print_info \"=== Phase 2: Unsealing Vault pods ===\"\n    print_info \"Total replicas: ${replicas}\"\n\n    local unsealed_count=0\n    local failed_count=0\n\n    for ((i=0; i\u003creplicas; i++)); do\n        local pod=\"${RELEASE_NAME}-${i}\"\n\n        # Wait for pod to be ready\n        if wait_for_pod \"${pod}\"; then\n            if unseal_pod \"${pod}\" \"${init_data}\"; then\n                unsealed_count=$((unsealed_count + 1))\n\n                # Join to Raft cluster if this is a follower node (not vault-0)\n                if [[ \"${pod}\" != \"${RELEASE_NAME}-0\" ]]; then\n                    if join_follower_to_raft \"${pod}\"; then\n                        print_debug \"${pod} successfully joined to Raft cluster\"\n                    else\n                        print_warning \"${pod} unsealed but not joined to cluster yet\"\n                    fi\n                fi\n            else\n                failed_count=$((failed_count + 1))\n            fi\n        else\n            print_warning \"Skipping ${pod} - not ready\"\n            failed_count=$((failed_count + 1))\n        fi\n    done\n\n    echo \"\"\n    echo \"======================================================================\"\n    print_info \"Unseal Summary:\"\n    echo \"  Total replicas:  ${replicas}\"\n    echo \"  Unsealed:        ${unsealed_count}\"\n    echo \"  Failed:          ${failed_count}\"\n    echo \"======================================================================\"\n    echo \"\"\n\n    if [[ ${unsealed_count} -gt 0 ]]; then\n        return 0\n    else\n        return 1\n    fi\n}\n\n# Verify cluster health\nverify_cluster() {\n    local leader_pod=\"${RELEASE_NAME}-0\"\n    local replicas\n    replicas=$(get_replica_count)\n\n    print_info \"=== Phase 3: Verifying cluster health ===\"\n\n    # Get root token from secret\n    local root_token\n    root_token=$(kubectl get secret \"${SECRET_NAME}\" -n \"${NAMESPACE}\" \\\n        -o jsonpath='{.data.root_token}' 2\u003e/dev/null | base64 -d || echo \"\")\n\n    if [[ -z \"${root_token}\" ]]; then\n        print_warning \"Could not retrieve root token from secret\"\n        return 1\n    fi\n\n    # Check seal status of all pods\n    print_info \"Checking status of all pods...\"\n    for ((i=0; i\u003creplicas; i++)); do\n        local pod=\"${RELEASE_NAME}-${i}\"\n        if kubectl -n \"${NAMESPACE}\" get pod \"${pod}\" \u0026\u003e /dev/null; then\n            echo \"\"\n            print_info \"Status of ${pod}:\"\n            kubectl -n \"${NAMESPACE}\" exec \"${pod}\" -- vault status || true\n        fi\n    done\n\n    # Check Raft cluster members (if HA mode)\n    if [[ ${replicas} -gt 1 ]]; then\n        echo \"\"\n        print_info \"Checking Raft cluster peers...\"\n        if kubectl -n \"${NAMESPACE}\" exec \"${leader_pod}\" -- \\\n            env VAULT_TOKEN=\"${root_token}\" vault operator raft list-peers 2\u003e/dev/null; then\n\n            # Count actual members\n            local member_count\n            member_count=$(kubectl -n \"${NAMESPACE}\" exec \"${leader_pod}\" -- \\\n                env VAULT_TOKEN=\"${root_token}\" vault operator raft list-peers 2\u003e/dev/null | \\\n                grep -c \"vault-\" || echo \"0\")\n\n            if [[ ${member_count} -eq ${replicas} ]]; then\n                print_success \"All ${replicas} nodes are in the Raft cluster\"\n            elif [[ ${member_count} -gt 0 ]]; then\n                print_warning \"Only ${member_count} of ${replicas} nodes in Raft cluster\"\n            else\n                print_warning \"Could not count Raft cluster members\"\n            fi\n        else\n            print_warning \"Failed to list Raft peers - cluster may not be fully formed yet\"\n        fi\n    fi\n\n    print_success \"Cluster verification complete\"\n}\n\n# Display access information\ndisplay_info() {\n    local root_token\n    root_token=$(kubectl get secret \"${SECRET_NAME}\" -n \"${NAMESPACE}\" \\\n        -o jsonpath='{.data.root_token}' 2\u003e/dev/null | base64 -d || echo \"\u003cerror-retrieving-token\u003e\")\n\n    echo \"\"\n    echo \"======================================================================\"\n    print_success \"Vault cluster initialized and unsealed successfully!\"\n    echo \"======================================================================\"\n    echo \"\"\n    echo \"Access Information:\"\n    echo \"  Namespace:     ${NAMESPACE}\"\n    echo \"  Release:       ${RELEASE_NAME}\"\n    echo \"  Replicas:      $(get_replica_count)\"\n    echo \"  Secret Name:   ${SECRET_NAME}\"\n    echo \"\"\n    echo \"Root Token: ${root_token}\"\n    echo \"\"\n    print_warning \"IMPORTANT: Credentials are stored in Kubernetes Secret: ${SECRET_NAME}\"\n    print_warning \"This is suitable for dev/test only. For production, use Cloud KMS auto-unseal.\"\n    echo \"\"\n    echo \"To retrieve the root token:\"\n    echo \"  kubectl get secret ${SECRET_NAME} -n ${NAMESPACE} -o jsonpath='{.data.root_token}' | base64 -d\"\n    echo \"\"\n    echo \"To access Vault:\"\n    echo \"  kubectl port-forward -n ${NAMESPACE} svc/${RELEASE_NAME} 8200:8200\"\n    echo \"  export VAULT_ADDR=http://localhost:8200\"\n    echo \"  export VAULT_TOKEN=\\\"${root_token}\\\"\"\n    echo \"  vault status\"\n    echo \"\"\n}\n\n# Main execution\nmain() {\n    echo \"\"\n    echo \"======================================================================\"\n    echo \"  Vault Auto-Initialization for Kubernetes\"\n    echo \"======================================================================\"\n    echo \"\"\n    echo \"Configuration:\"\n    echo \"  Namespace:        ${NAMESPACE}\"\n    echo \"  Release Name:     ${RELEASE_NAME}\"\n    echo \"  Key Shares:       ${KEY_SHARES}\"\n    echo \"  Key Threshold:    ${KEY_THRESHOLD}\"\n    echo \"  Secret Name:      ${SECRET_NAME}\"\n    echo \"  Auto Unseal:      ${AUTO_UNSEAL}\"\n    echo \"  Max Retries:      ${MAX_RETRY}\"\n    echo \"  Timeout:          ${OPERATION_TIMEOUT}s\"\n    echo \"  Debug Mode:       ${DEBUG}\"\n    echo \"\"\n\n    validate_environment\n    configure_kubectl\n    check_prerequisites\n\n    # Check if already initialized\n    if is_vault_initialized; then\n        print_warning \"Vault is already initialized!\"\n\n        if secret_exists; then\n            print_info \"Initialization secret exists: ${SECRET_NAME}\"\n        else\n            print_error \"Vault is initialized but secret ${SECRET_NAME} not found!\"\n            print_error \"Cannot proceed without unseal keys\"\n            exit 1\n        fi\n\n        # Check if we need to unseal\n        if [[ \"${AUTO_UNSEAL}\" == \"true\" ]]; then\n            print_info \"Checking if unsealing is needed...\"\n\n            # Retrieve init data from secret\n            local unseal_keys_b64\n            unseal_keys_b64=$(kubectl get secret \"${SECRET_NAME}\" -n \"${NAMESPACE}\" \\\n                -o jsonpath='{.data.unseal_keys_b64}' 2\u003e/dev/null | base64 -d || echo \"\")\n\n            if [[ -z \"${unseal_keys_b64}\" ]]; then\n                print_error \"Failed to retrieve unseal keys from secret\"\n                exit 1\n            fi\n\n            local init_data\n            init_data=$(jq -n --argjson keys \"${unseal_keys_b64}\" '{\"unseal_keys_b64\": $keys}')\n\n            if unseal_cluster \"${init_data}\"; then\n                verify_cluster\n            fi\n        fi\n    else\n        print_info \"Vault is not initialized. Starting initialization...\"\n\n        # Initialize Vault\n        if ! initialize_vault; then\n            print_error \"Initialization failed\"\n            exit 1\n        fi\n\n        # Unseal if enabled\n        if [[ \"${AUTO_UNSEAL}\" == \"true\" ]]; then\n            if unseal_cluster \"${INIT_OUTPUT}\"; then\n                verify_cluster\n            fi\n        fi\n    fi\n\n    display_info\n\n    echo \"\"\n    print_success \"Auto-initialization complete!\"\n    echo \"\"\n}\n\nmain \"$@\"\n",
              "unseal-vault.sh": "#!/usr/bin/env bash\n# Vault Unseal Script for Kubernetes\n# This script unseals all Vault pods by retrieving keys from Kubernetes Secret\n# Designed to run after pod restarts or cluster failures\n\nset -euo pipefail\n\n# Configuration from environment variables\nNAMESPACE=\"${VAULT_NAMESPACE:-vault}\"\nRELEASE_NAME=\"${VAULT_RELEASE:-vault}\"\nSECRET_NAME=\"${VAULT_SECRET_NAME:-vault-unseal-keys}\"\nKEY_THRESHOLD=\"${VAULT_KEY_THRESHOLD:-3}\"\nMAX_RETRY=\"${MAX_RETRY_ATTEMPTS:-5}\"\nPOD_TIMEOUT=\"${POD_TIMEOUT:-120}\"\nDEBUG=\"${DEBUG:-false}\"\n\n# Color definitions for output\nreadonly RED='\\033[0;31m'\nreadonly GREEN='\\033[0;32m'\nreadonly YELLOW='\\033[1;33m'\nreadonly BLUE='\\033[0;34m'\nreadonly NC='\\033[0m' # No Color\n\n# Logging functions\nlog_with_timestamp() {\n    local level=$1\n    shift\n    echo -e \"[$(date +'%Y-%m-%d %H:%M:%S')] [${level}] $*\"\n}\n\nprint_info() {\n    log_with_timestamp \"INFO\" \"${BLUE}[INFO]${NC} $1\"\n}\n\nprint_success() {\n    log_with_timestamp \"SUCCESS\" \"${GREEN}[SUCCESS]${NC} $1\"\n}\n\nprint_warning() {\n    log_with_timestamp \"WARNING\" \"${YELLOW}[WARNING]${NC} $1\"\n}\n\nprint_error() {\n    log_with_timestamp \"ERROR\" \"${RED}[ERROR]${NC} $1\"\n}\n\nprint_debug() {\n    if [[ \"${DEBUG}\" == \"true\" ]]; then\n        log_with_timestamp \"DEBUG\" \"[DEBUG] $1\"\n    fi\n}\n\n# Retry helper function with exponential backoff\nretry_command() {\n    local max_attempts=$1\n    shift\n    local cmd=(\"$@\")\n    local attempt=1\n    local delay=2\n\n    while [ $attempt -le $max_attempts ]; do\n        print_debug \"Attempt $attempt/$max_attempts: ${cmd[*]}\"\n\n        if \"${cmd[@]}\"; then\n            return 0\n        fi\n\n        if [ $attempt -lt $max_attempts ]; then\n            print_warning \"Command failed, retrying in ${delay}s... (attempt $attempt/$max_attempts)\"\n            sleep $delay\n            delay=$((delay * 2))  # Exponential backoff\n            attempt=$((attempt + 1))\n        else\n            print_error \"Command failed after $max_attempts attempts\"\n            return 1\n        fi\n    done\n}\n\n# Cleanup function for error handling\ncleanup_on_error() {\n    local exit_code=$?\n    if [ $exit_code -ne 0 ]; then\n        print_error \"Script failed with exit code: $exit_code\"\n    fi\n}\n\ntrap cleanup_on_error EXIT\n\n# Validate environment variables\nvalidate_environment() {\n    print_info \"Validating environment variables...\"\n\n    local required_vars=(\"NAMESPACE\" \"RELEASE_NAME\" \"SECRET_NAME\" \"KEY_THRESHOLD\")\n    local missing_vars=()\n\n    for var in \"${required_vars[@]}\"; do\n        if [[ -z \"${!var:-}\" ]]; then\n            missing_vars+=(\"$var\")\n        fi\n    done\n\n    if [ ${#missing_vars[@]} -gt 0 ]; then\n        print_error \"Missing required environment variables: ${missing_vars[*]}\"\n        exit 1\n    fi\n\n    # Validate numeric values\n    if ! [[ \"$KEY_THRESHOLD\" =~ ^[0-9]+$ ]] || [ \"$KEY_THRESHOLD\" -lt 1 ]; then\n        print_error \"KEY_THRESHOLD must be a positive integer\"\n        exit 1\n    fi\n\n    print_success \"Environment validation passed\"\n}\n\n# Check prerequisites\ncheck_prerequisites() {\n    print_info \"Checking prerequisites...\"\n\n    if ! command -v kubectl \u0026\u003e /dev/null; then\n        print_error \"kubectl is not installed or not in PATH\"\n        exit 1\n    fi\n\n    if ! command -v jq \u0026\u003e /dev/null; then\n        print_error \"jq is required for parsing unseal keys\"\n        exit 1\n    fi\n\n    # Verify kubectl can access cluster (list pods in namespace)\n    if ! kubectl get pods -n \"${NAMESPACE}\" \u0026\u003e /dev/null; then\n        print_error \"Cannot connect to Kubernetes cluster or access namespace '${NAMESPACE}'\"\n        exit 1\n    fi\n\n    print_success \"Prerequisites check passed\"\n}\n\n# Check if Kubernetes Secret exists\ncheck_secret_exists() {\n    print_info \"Checking for initialization secret...\"\n\n    if ! retry_command ${MAX_RETRY} kubectl get secret \"${SECRET_NAME}\" -n \"${NAMESPACE}\" \u0026\u003e/dev/null; then\n        print_error \"Secret '${SECRET_NAME}' not found in namespace '${NAMESPACE}'\"\n        print_error \"Run k8s-init-vault.sh first to initialize the cluster\"\n        exit 1\n    fi\n\n    print_success \"Secret ${SECRET_NAME} found\"\n}\n\n# Retrieve and decode secret data\nget_vault_secret() {\n    print_info \"Retrieving unseal keys from secret...\"\n\n    local secret_data\n    if ! secret_data=$(retry_command ${MAX_RETRY} kubectl get secret \"${SECRET_NAME}\" -n \"${NAMESPACE}\" -o json 2\u003e\u00261); then\n        print_error \"Failed to retrieve secret ${SECRET_NAME}\"\n        print_error \"Error: ${secret_data}\"\n        exit 1\n    fi\n\n    # Decode unseal keys\n    local unseal_keys_b64\n    unseal_keys_b64=$(echo \"${secret_data}\" | jq -r '.data.unseal_keys_b64' | base64 -d 2\u003e/dev/null || echo \"\")\n\n    if [[ -z \"${unseal_keys_b64}\" || \"${unseal_keys_b64}\" == \"null\" ]]; then\n        print_error \"Failed to decode unseal_keys_b64 from secret\"\n        exit 1\n    fi\n\n    # Validate key array length\n    local key_count\n    key_count=$(echo \"${unseal_keys_b64}\" | jq '. | length' 2\u003e/dev/null || echo \"0\")\n\n    print_debug \"Found ${key_count} unseal keys in secret\"\n\n    if [[ ${key_count} -lt ${KEY_THRESHOLD} ]]; then\n        print_error \"Not enough keys in secret. Need ${KEY_THRESHOLD}, found ${key_count}\"\n        exit 1\n    fi\n\n    # Also get key threshold from secret if available\n    local stored_threshold\n    stored_threshold=$(echo \"${secret_data}\" | jq -r '.data.key_threshold' | base64 -d 2\u003e/dev/null || echo \"\")\n\n    if [[ -n \"${stored_threshold}\" \u0026\u0026 \"${stored_threshold}\" != \"null\" ]]; then\n        if [[ \"${stored_threshold}\" != \"${KEY_THRESHOLD}\" ]]; then\n            print_warning \"KEY_THRESHOLD (${KEY_THRESHOLD}) differs from stored value (${stored_threshold})\"\n            print_warning \"Using stored value: ${stored_threshold}\"\n            KEY_THRESHOLD=\"${stored_threshold}\"\n        fi\n    fi\n\n    print_success \"Retrieved unseal keys from secret\"\n\n    # Export for use in unsealing\n    export UNSEAL_KEYS=\"${unseal_keys_b64}\"\n}\n\n# Get replica count\nget_replica_count() {\n    local replicas\n    replicas=$(kubectl -n \"${NAMESPACE}\" get statefulset \"${RELEASE_NAME}\" \\\n        -o jsonpath='{.spec.replicas}' 2\u003e/dev/null || echo \"1\")\n    echo \"${replicas}\"\n}\n\n# Check if pod is sealed\nis_pod_sealed() {\n    local pod=$1\n\n    if ! kubectl -n \"${NAMESPACE}\" get pod \"${pod}\" \u0026\u003e /dev/null; then\n        print_debug \"Pod ${pod} does not exist\"\n        return 1\n    fi\n\n    # Get vault status output (text format is more reliable than JSON when sealed)\n    local status_output\n    status_output=$(kubectl -n \"${NAMESPACE}\" exec \"${pod}\" -- vault status 2\u003e\u00261 || true)\n\n    # Parse the \"Sealed\" field from the output\n    local sealed\n    sealed=$(echo \"${status_output}\" | grep -E \"^Sealed\" | awk '{print $2}' || echo \"\")\n\n    print_debug \"Pod ${pod} sealed status: '${sealed}'\"\n\n    if [[ \"${sealed}\" == \"true\" ]]; then\n        return 0  # Pod is sealed\n    elif [[ \"${sealed}\" == \"false\" ]]; then\n        return 1  # Pod is not sealed\n    else\n        # Unable to determine status, assume sealed to be safe\n        print_debug \"Could not determine sealed status for ${pod}, assuming sealed\"\n        return 0\n    fi\n}\n\n# Unseal a single pod\nunseal_pod() {\n    local pod=$1\n\n    print_info \"Processing pod: ${pod}...\"\n\n    # Check if pod exists and is running\n    if ! kubectl -n \"${NAMESPACE}\" get pod \"${pod}\" \u0026\u003e /dev/null; then\n        print_warning \"Pod ${pod} does not exist, skipping\"\n        return 1\n    fi\n\n    local pod_status\n    pod_status=$(kubectl -n \"${NAMESPACE}\" get pod \"${pod}\" -o jsonpath='{.status.phase}' 2\u003e/dev/null || echo \"Unknown\")\n\n    if [[ \"${pod_status}\" != \"Running\" ]]; then\n        print_warning \"Pod ${pod} is not running (status: ${pod_status}), skipping\"\n        return 1\n    fi\n\n    # Check if already unsealed\n    if ! is_pod_sealed \"${pod}\"; then\n        print_info \"Pod ${pod} is already unsealed\"\n        return 0\n    fi\n\n    print_info \"Unsealing pod ${pod}...\"\n\n    # Extract unseal keys from environment variable\n    local keys=()\n    for ((i=0; i\u003cKEY_THRESHOLD; i++)); do\n        local key\n        key=$(echo \"${UNSEAL_KEYS}\" | jq -r \".[${i}]\")\n\n        if [[ -z \"${key}\" || \"${key}\" == \"null\" ]]; then\n            print_error \"Invalid or missing unseal key at index ${i}\"\n            return 1\n        fi\n\n        keys+=(\"${key}\")\n    done\n\n    # Unseal with threshold number of keys\n    local unseal_count=0\n    for key in \"${keys[@]}\"; do\n        if retry_command 3 kubectl -n \"${NAMESPACE}\" exec \"${pod}\" -- \\\n            vault operator unseal \"${key}\" \u003e /dev/null 2\u003e\u00261; then\n            unseal_count=$((unseal_count + 1))\n        else\n            print_error \"Failed to apply unseal key to ${pod}\"\n            return 1\n        fi\n    done\n\n    # Verify unsealed\n    if ! is_pod_sealed \"${pod}\"; then\n        print_success \"Pod ${pod} unsealed successfully\"\n        return 0\n    else\n        print_error \"Pod ${pod} still sealed after applying ${unseal_count} keys\"\n        return 1\n    fi\n}\n\n# Join follower node to Raft cluster (if not already a member)\njoin_follower_to_raft() {\n    local follower_pod=$1\n    local leader_pod=\"${RELEASE_NAME}-0\"\n\n    # Skip if this is the leader pod\n    if [[ \"${follower_pod}\" == \"${leader_pod}\" ]]; then\n        print_debug \"${follower_pod} is the leader, skipping join\"\n        return 0\n    fi\n\n    print_info \"Checking if ${follower_pod} needs to join Raft cluster...\"\n\n    # Check if already a member using raft_joined status\n    local is_member\n    is_member=$(kubectl -n \"${NAMESPACE}\" exec \"${follower_pod}\" -- \\\n        vault status -format=json 2\u003e/dev/null | jq -r '.raft_joined' || echo \"false\")\n\n    if [[ \"${is_member}\" == \"true\" ]]; then\n        print_debug \"${follower_pod} is already a member of the Raft cluster\"\n        return 0\n    fi\n\n    # Get leader address\n    local leader_addr=\"http://${leader_pod}.${RELEASE_NAME}-internal:8200\"\n\n    print_info \"Joining ${follower_pod} to Raft cluster...\"\n\n    # Attempt to join the Raft cluster\n    local join_output\n    if join_output=$(kubectl -n \"${NAMESPACE}\" exec \"${follower_pod}\" -- \\\n        vault operator raft join \"${leader_addr}\" 2\u003e\u00261); then\n        print_success \"${follower_pod} joined Raft cluster successfully\"\n\n        # Wait for cluster sync\n        sleep 2\n        return 0\n    else\n        # Check if error is due to already being a member\n        if echo \"${join_output}\" | grep -q \"node already part of cluster\\|already joined\"; then\n            print_debug \"${follower_pod} is already a member of the Raft cluster\"\n            return 0\n        else\n            print_warning \"Failed to join ${follower_pod} to Raft cluster\"\n            print_debug \"Join output: ${join_output}\"\n            return 1\n        fi\n    fi\n}\n\n# Unseal all pods\nunseal_all_pods() {\n    local replicas\n    replicas=$(get_replica_count)\n\n    print_info \"=== Unsealing Vault pods ===\"\n    print_info \"Found ${replicas} replica(s)\"\n\n    local unsealed_count=0\n    local already_unsealed=0\n    local failed_count=0\n    local skipped_count=0\n\n    for ((i=0; i\u003creplicas; i++)); do\n        local pod=\"${RELEASE_NAME}-${i}\"\n\n        # Check if pod is already unsealed before attempting\n        if kubectl -n \"${NAMESPACE}\" get pod \"${pod}\" \u0026\u003e /dev/null; then\n            if ! is_pod_sealed \"${pod}\"; then\n                print_info \"Pod ${pod} is already unsealed, skipping\"\n                already_unsealed=$((already_unsealed + 1))\n                continue\n            fi\n        fi\n\n        if unseal_pod \"${pod}\"; then\n            unsealed_count=$((unsealed_count + 1))\n\n            # Join to Raft cluster if this is a follower node (not vault-0)\n            if [[ \"${pod}\" != \"${RELEASE_NAME}-0\" ]]; then\n                if join_follower_to_raft \"${pod}\"; then\n                    print_debug \"${pod} successfully joined to Raft cluster\"\n                else\n                    print_warning \"${pod} unsealed but may not be joined to cluster\"\n                fi\n            fi\n        else\n            if kubectl -n \"${NAMESPACE}\" get pod \"${pod}\" \u0026\u003e /dev/null; then\n                local pod_status\n                pod_status=$(kubectl -n \"${NAMESPACE}\" get pod \"${pod}\" -o jsonpath='{.status.phase}')\n                if [[ \"${pod_status}\" == \"Running\" ]]; then\n                    failed_count=$((failed_count + 1))\n                else\n                    skipped_count=$((skipped_count + 1))\n                fi\n            else\n                skipped_count=$((skipped_count + 1))\n            fi\n        fi\n    done\n\n    echo \"\"\n    echo \"======================================================================\"\n    print_info \"Unseal Summary:\"\n    echo \"  Total replicas:     ${replicas}\"\n    echo \"  Already unsealed:   ${already_unsealed}\"\n    echo \"  Newly unsealed:     ${unsealed_count}\"\n    echo \"  Failed:             ${failed_count}\"\n    echo \"  Skipped:            ${skipped_count}\"\n    echo \"======================================================================\"\n    echo \"\"\n\n    local total_unsealed=$((already_unsealed + unsealed_count))\n    if [[ ${total_unsealed} -gt 0 ]]; then\n        return 0\n    else\n        return 1\n    fi\n}\n\n# Display cluster status\ndisplay_status() {\n    local replicas\n    replicas=$(get_replica_count)\n\n    print_info \"=== Cluster Status ===\"\n\n    for ((i=0; i\u003creplicas; i++)); do\n        local pod=\"${RELEASE_NAME}-${i}\"\n\n        if kubectl -n \"${NAMESPACE}\" get pod \"${pod}\" \u0026\u003e /dev/null; then\n            echo \"\"\n            print_info \"Status of ${pod}:\"\n            kubectl -n \"${NAMESPACE}\" exec \"${pod}\" -- vault status 2\u003e/dev/null || \\\n                print_warning \"Could not get status for ${pod}\"\n        fi\n    done\n\n    # If HA mode, show Raft peers\n    if [[ ${replicas} -gt 1 ]]; then\n        echo \"\"\n        print_info \"=== Raft Cluster Peers ===\"\n\n        # Try to get root token from secret\n        local root_token\n        root_token=$(kubectl get secret \"${SECRET_NAME}\" -n \"${NAMESPACE}\" \\\n            -o jsonpath='{.data.root_token}' 2\u003e/dev/null | base64 -d || echo \"\")\n\n        if [[ -n \"${root_token}\" ]]; then\n            kubectl -n \"${NAMESPACE}\" exec \"${RELEASE_NAME}-0\" -- \\\n                env VAULT_TOKEN=\"${root_token}\" vault operator raft list-peers 2\u003e/dev/null || \\\n                print_warning \"Unable to list Raft peers (authentication may be required)\"\n        else\n            print_warning \"Cannot list Raft peers - root token not available\"\n            echo \"\"\n            print_info \"To manually check cluster peers, run:\"\n            echo \"  ROOT_TOKEN=\\$(kubectl get secret ${SECRET_NAME} -n ${NAMESPACE} -o jsonpath='{.data.root_token}' | base64 -d)\"\n            echo \"  kubectl exec -n ${NAMESPACE} ${RELEASE_NAME}-0 -- env VAULT_TOKEN=\\$ROOT_TOKEN vault operator raft list-peers\"\n        fi\n    fi\n}\n\n# Main execution\nmain() {\n    echo \"\"\n    echo \"======================================================================\"\n    echo \"  Vault Unseal Script for Kubernetes\"\n    echo \"======================================================================\"\n    echo \"\"\n    echo \"Configuration:\"\n    echo \"  Namespace:        ${NAMESPACE}\"\n    echo \"  Release Name:     ${RELEASE_NAME}\"\n    echo \"  Secret Name:      ${SECRET_NAME}\"\n    echo \"  Key Threshold:    ${KEY_THRESHOLD}\"\n    echo \"  Max Retries:      ${MAX_RETRY}\"\n    echo \"  Pod Timeout:      ${POD_TIMEOUT}s\"\n    echo \"  Debug Mode:       ${DEBUG}\"\n    echo \"\"\n\n    validate_environment\n    check_prerequisites\n    check_secret_exists\n    get_vault_secret\n\n    if unseal_all_pods; then\n        print_success \"Unseal operation completed successfully!\"\n    else\n        print_warning \"Some pods could not be unsealed\"\n    fi\n\n    display_status\n\n    echo \"\"\n    print_info \"To access Vault:\"\n    echo \"  kubectl port-forward -n ${NAMESPACE} svc/${RELEASE_NAME} 8200:8200\"\n    echo \"  export VAULT_ADDR=http://localhost:8200\"\n    echo \"  export VAULT_TOKEN=\\$(kubectl get secret ${SECRET_NAME} -n ${NAMESPACE} -o jsonpath='{.data.root_token}' | base64 -d)\"\n    echo \"  vault status\"\n    echo \"\"\n}\n\nmain \"$@\"\n"
            },
            "id": "vault/vault-init-scripts",
            "immutable": false,
            "metadata": [
              {
                "annotations": null,
                "generate_name": "",
                "generation": 0,
                "labels": {
                  "app.kubernetes.io/component": "initialization",
                  "app.kubernetes.io/managed-by": "terraform",
                  "app.kubernetes.io/name": "vault-init",
                  "app.kubernetes.io/part-of": "vault"
                },
                "name": "vault-init-scripts",
                "namespace": "vault",
                "resource_version": "220209",
                "uid": "f3b1a0fa-f109-4a82-9a3b-042c711d870f"
              }
            ]
          },
          "sensitive_attributes": [],
          "identity_schema_version": 1,
          "identity": {
            "api_version": "v1",
            "kind": "ConfigMap",
            "name": "vault-init-scripts",
            "namespace": "vault"
          },
          "private": "bnVsbA==",
          "dependencies": [
            "kubernetes_namespace.vault"
          ]
        }
      ]
    },
    {
      "mode": "managed",
      "type": "kubernetes_ingress_v1",
      "name": "vault_ui",
      "provider": "provider[\"registry.terraform.io/hashicorp/kubernetes\"]",
      "instances": [
        {
          "index_key": 0,
          "schema_version": 0,
          "attributes": {
            "id": "vault/vault-ui",
            "metadata": [
              {
                "annotations": {
                  "kubernetes.io/ingress.class": "nginx"
                },
                "generate_name": "",
                "generation": 1,
                "labels": {
                  "app.kubernetes.io/component": "ui",
                  "app.kubernetes.io/name": "vault"
                },
                "name": "vault-ui",
                "namespace": "vault",
                "resource_version": "220441",
                "uid": "acd3de87-79ff-491c-91dc-b4023c216cad"
              }
            ],
            "spec": [
              {
                "default_backend": [],
                "ingress_class_name": "nginx",
                "rule": [
                  {
                    "host": "vault.local",
                    "http": [
                      {
                        "path": [
                          {
                            "backend": [
                              {
                                "resource": [],
                                "service": [
                                  {
                                    "name": "vault-ui",
                                    "port": [
                                      {
                                        "name": "",
                                        "number": 8200
                                      }
                                    ]
                                  }
                                ]
                              }
                            ],
                            "path": "/",
                            "path_type": "Prefix"
                          }
                        ]
                      }
                    ]
                  }
                ],
                "tls": []
              }
            ],
            "status": [
              {
                "load_balancer": [
                  {
                    "ingress": []
                  }
                ]
              }
            ],
            "timeouts": null,
            "wait_for_load_balancer": null
          },
          "sensitive_attributes": [],
          "identity_schema_version": 1,
          "identity": {
            "api_version": "networking.k8s.io/v1",
            "kind": "Ingress",
            "name": "vault-ui",
            "namespace": "vault"
          },
          "private": "eyJlMmJmYjczMC1lY2FhLTExZTYtOGY4OC0zNDM2M2JjN2M0YzAiOnsiY3JlYXRlIjoxMjAwMDAwMDAwMDAwLCJkZWxldGUiOjEyMDAwMDAwMDAwMDB9fQ==",
          "dependencies": [
            "helm_release.vault",
            "kubernetes_namespace.vault"
          ]
        }
      ]
    },
    {
      "mode": "managed",
      "type": "kubernetes_job_v1",
      "name": "vault_init",
      "provider": "provider[\"registry.terraform.io/hashicorp/kubernetes\"]",
      "instances": [
        {
          "index_key": 0,
          "schema_version": 1,
          "attributes": {
            "id": "vault/vault-auto-init",
            "metadata": [
              {
                "annotations": null,
                "generate_name": "",
                "generation": 1,
                "labels": {
                  "app.kubernetes.io/component": "initialization",
                  "app.kubernetes.io/managed-by": "terraform",
                  "app.kubernetes.io/name": "vault-init",
                  "app.kubernetes.io/part-of": "vault"
                },
                "name": "vault-auto-init",
                "namespace": "vault",
                "resource_version": "220442",
                "uid": "dd939a17-31bf-40e6-91f9-ce011c656f5a"
              }
            ],
            "spec": [
              {
                "active_deadline_seconds": 0,
                "backoff_limit": 3,
                "backoff_limit_per_index": 0,
                "completion_mode": "NonIndexed",
                "completions": 1,
                "manual_selector": false,
                "max_failed_indexes": 0,
                "parallelism": 1,
                "pod_failure_policy": [],
                "selector": [
                  {
                    "match_expressions": null,
                    "match_labels": null
                  }
                ],
                "template": [
                  {
                    "metadata": [
                      {
                        "annotations": null,
                        "generate_name": "",
                        "generation": 0,
                        "labels": {
                          "app.kubernetes.io/component": "initialization",
                          "app.kubernetes.io/name": "vault-init",
                          "app.kubernetes.io/part-of": "vault"
                        },
                        "name": "",
                        "resource_version": "",
                        "uid": ""
                      }
                    ],
                    "spec": [
                      {
                        "active_deadline_seconds": 0,
                        "affinity": [],
                        "automount_service_account_token": true,
                        "container": [
                          {
                            "args": [
                              "set -e\n\n# Install bash and jq if not present (alpine/k8s doesn't include them)\necho \"Installing dependencies...\"\napk add --no-cache bash jq\n\n# Configure kubectl to use in-cluster config\n# The ServiceAccount token is mounted at /var/run/secrets/kubernetes.io/serviceaccount/\necho \"Configuring kubectl for in-cluster access...\"\nkubectl config set-cluster kubernetes \\\n  --server=https://kubernetes.default.svc \\\n  --certificate-authority=/var/run/secrets/kubernetes.io/serviceaccount/ca.crt\n\nkubectl config set-credentials serviceaccount \\\n  --token=$(cat /var/run/secrets/kubernetes.io/serviceaccount/token)\n\nkubectl config set-context default \\\n  --cluster=kubernetes \\\n  --user=serviceaccount \\\n  --namespace=vault\n\nkubectl config use-context default\n\n# Verify kubectl works\necho \"Verifying kubectl connectivity...\"\nkubectl version --client\n\n# Run the init script (already executable from ConfigMap defaultMode=0755)\necho \"Starting Vault initialization...\"\nbash /scripts/init-vault.sh\n"
                            ],
                            "command": [
                              "/bin/sh",
                              "-c"
                            ],
                            "env": [
                              {
                                "name": "VAULT_NAMESPACE",
                                "value": "vault",
                                "value_from": []
                              },
                              {
                                "name": "VAULT_RELEASE",
                                "value": "vault",
                                "value_from": []
                              },
                              {
                                "name": "VAULT_KEY_SHARES",
                                "value": "5",
                                "value_from": []
                              },
                              {
                                "name": "VAULT_KEY_THRESHOLD",
                                "value": "3",
                                "value_from": []
                              },
                              {
                                "name": "VAULT_SECRET_NAME",
                                "value": "vault-unseal-keys",
                                "value_from": []
                              },
                              {
                                "name": "AUTO_UNSEAL",
                                "value": "true",
                                "value_from": []
                              },
                              {
                                "name": "MAX_RETRY_ATTEMPTS",
                                "value": "5",
                                "value_from": []
                              },
                              {
                                "name": "OPERATION_TIMEOUT",
                                "value": "300",
                                "value_from": []
                              },
                              {
                                "name": "DEBUG",
                                "value": "false",
                                "value_from": []
                              }
                            ],
                            "env_from": [],
                            "image": "alpine/k8s:1.31.1",
                            "image_pull_policy": "IfNotPresent",
                            "lifecycle": [],
                            "liveness_probe": [],
                            "name": "vault-initializer",
                            "port": [],
                            "readiness_probe": [],
                            "resources": [
                              {
                                "limits": {
                                  "cpu": "200m",
                                  "memory": "256Mi"
                                },
                                "requests": {
                                  "cpu": "100m",
                                  "memory": "128Mi"
                                }
                              }
                            ],
                            "security_context": [],
                            "startup_probe": [],
                            "stdin": false,
                            "stdin_once": false,
                            "termination_message_path": "/dev/termination-log",
                            "termination_message_policy": "File",
                            "tty": false,
                            "volume_device": [],
                            "volume_mount": [
                              {
                                "mount_path": "/scripts",
                                "mount_propagation": "None",
                                "name": "scripts",
                                "read_only": true,
                                "sub_path": "",
                                "sub_path_expr": ""
                              }
                            ],
                            "working_dir": ""
                          }
                        ],
                        "dns_config": [],
                        "dns_policy": "ClusterFirst",
                        "enable_service_links": true,
                        "host_aliases": [],
                        "host_ipc": false,
                        "host_network": false,
                        "host_pid": false,
                        "hostname": "",
                        "image_pull_secrets": [],
                        "init_container": [
                          {
                            "args": [
                              "# Install bash and jq if not present (alpine/k8s doesn't include them)\nif ! command -v bash \u0026\u003e /dev/null || ! command -v jq \u0026\u003e /dev/null; then\n  echo \"Installing bash and jq...\"\n  apk add --no-cache bash jq\nfi\n\n# Switch to bash for the rest of the script\nbash \u003c\u003c'BASH_SCRIPT'\nset -e\necho \"[$(date +'%Y-%m-%d %H:%M:%S')] Waiting for Vault pods to be Running and responsive...\"\n\n# Get expected replica count\nREPLICAS=$(kubectl get statefulset vault -n vault -o jsonpath='{.spec.replicas}' 2\u003e/dev/null || echo \"3\")\necho \"[$(date +'%Y-%m-%d %H:%M:%S')] Expected replicas: $REPLICAS\"\n\nMAX_WAIT=300\nELAPSED=0\n\nwhile [ $ELAPSED -lt $MAX_WAIT ]; do\n  # Check if statefulset exists\n  if ! kubectl get statefulset vault -n vault \u0026\u003e/dev/null; then\n    echo \"[$(date +'%Y-%m-%d %H:%M:%S')] Waiting for StatefulSet vault to be created...\"\n    sleep 5\n    ELAPSED=$((ELAPSED + 5))\n    continue\n  fi\n\n  # Count pods in Running state (not Ready - they won't be ready until unsealed!)\n  RUNNING=$(kubectl get pods -n vault -l app.kubernetes.io/name=vault,component=server \\\n    -o jsonpath='{range .items[*]}{.status.phase}{\"\\n\"}{end}' 2\u003e/dev/null | grep -c \"Running\" || echo \"0\")\n\n  echo \"[$(date +'%Y-%m-%d %H:%M:%S')] Running pods: $RUNNING / $REPLICAS\"\n\n  if [ \"$RUNNING\" -ge \"$REPLICAS\" ]; then\n    echo \"[$(date +'%Y-%m-%d %H:%M:%S')] All Vault pods are running!\"\n\n    # Verify vault-0 can respond to commands (even if sealed)\n    # Vault responds to 'vault status' even when sealed\n    if kubectl exec -n vault vault-0 -- vault status \u0026\u003e/dev/null || \\\n       kubectl exec -n vault vault-0 -- vault status 2\u003e\u00261 | grep -q \"Sealed\"; then\n      echo \"[$(date +'%Y-%m-%d %H:%M:%S')] Vault is responsive! Proceeding with initialization...\"\n      exit 0\n    else\n      echo \"[$(date +'%Y-%m-%d %H:%M:%S')] Vault pods running but not responsive yet, waiting...\"\n    fi\n  fi\n\n  sleep 5\n  ELAPSED=$((ELAPSED + 5))\ndone\n\necho \"[$(date +'%Y-%m-%d %H:%M:%S')] ERROR: Vault pods did not become running and responsive within $MAX_WAIT seconds\"\necho \"[$(date +'%Y-%m-%d %H:%M:%S')] Current pod status:\"\nkubectl get pods -n vault -l app.kubernetes.io/name=vault\necho \"\"\necho \"[$(date +'%Y-%m-%d %H:%M:%S')] Attempting to get vault-0 status:\"\nkubectl exec -n vault vault-0 -- vault status 2\u003e\u00261 || true\nexit 1\nBASH_SCRIPT\n"
                            ],
                            "command": [
                              "/bin/sh",
                              "-c"
                            ],
                            "env": [],
                            "env_from": [],
                            "image": "alpine/k8s:1.31.1",
                            "image_pull_policy": "IfNotPresent",
                            "lifecycle": [],
                            "liveness_probe": [],
                            "name": "wait-for-vault-pods",
                            "port": [],
                            "readiness_probe": [],
                            "resources": [
                              {
                                "limits": {
                                  "cpu": "100m",
                                  "memory": "128Mi"
                                },
                                "requests": {
                                  "cpu": "50m",
                                  "memory": "64Mi"
                                }
                              }
                            ],
                            "security_context": [],
                            "startup_probe": [],
                            "stdin": false,
                            "stdin_once": false,
                            "termination_message_path": "/dev/termination-log",
                            "termination_message_policy": "File",
                            "tty": false,
                            "volume_device": [],
                            "volume_mount": [],
                            "working_dir": ""
                          }
                        ],
                        "node_name": "",
                        "node_selector": null,
                        "os": [],
                        "priority_class_name": "",
                        "readiness_gate": [],
                        "restart_policy": "OnFailure",
                        "runtime_class_name": "",
                        "scheduler_name": "default-scheduler",
                        "security_context": [],
                        "service_account_name": "vault-init",
                        "share_process_namespace": false,
                        "subdomain": "",
                        "termination_grace_period_seconds": 30,
                        "toleration": [],
                        "topology_spread_constraint": [],
                        "volume": [
                          {
                            "aws_elastic_block_store": [],
                            "azure_disk": [],
                            "azure_file": [],
                            "ceph_fs": [],
                            "cinder": [],
                            "config_map": [
                              {
                                "default_mode": "0755",
                                "items": [],
                                "name": "vault-init-scripts",
                                "optional": false
                              }
                            ],
                            "csi": [],
                            "downward_api": [],
                            "empty_dir": [],
                            "ephemeral": [],
                            "fc": [],
                            "flex_volume": [],
                            "flocker": [],
                            "gce_persistent_disk": [],
                            "git_repo": [],
                            "glusterfs": [],
                            "host_path": [],
                            "iscsi": [],
                            "local": [],
                            "name": "scripts",
                            "nfs": [],
                            "persistent_volume_claim": [],
                            "photon_persistent_disk": [],
                            "projected": [],
                            "quobyte": [],
                            "rbd": [],
                            "secret": [],
                            "vsphere_volume": []
                          }
                        ]
                      }
                    ]
                  }
                ],
                "ttl_seconds_after_finished": "300"
              }
            ],
            "timeouts": {
              "create": "10m",
              "delete": null,
              "update": "10m"
            },
            "wait_for_completion": false
          },
          "sensitive_attributes": [],
          "identity_schema_version": 1,
          "identity": {
            "api_version": "batch/v1",
            "kind": "Job",
            "name": "vault-auto-init",
            "namespace": "vault"
          },
          "private": "eyJlMmJmYjczMC1lY2FhLTExZTYtOGY4OC0zNDM2M2JjN2M0YzAiOnsiY3JlYXRlIjo2MDAwMDAwMDAwMDAsImRlbGV0ZSI6NjAwMDAwMDAwMDAsInVwZGF0ZSI6NjAwMDAwMDAwMDAwfSwic2NoZW1hX3ZlcnNpb24iOiIxIn0=",
          "dependencies": [
            "helm_release.vault",
            "kubernetes_config_map.vault_init_scripts",
            "kubernetes_namespace.vault",
            "kubernetes_role.vault_init",
            "kubernetes_role_binding.vault_init",
            "kubernetes_service_account.vault_init"
          ]
        }
      ]
    },
    {
      "mode": "managed",
      "type": "kubernetes_job_v1",
      "name": "vault_unseal_followers",
      "provider": "provider[\"registry.terraform.io/hashicorp/kubernetes\"]",
      "instances": [
        {
          "index_key": 0,
          "schema_version": 1,
          "attributes": {
            "id": "vault/vault-unseal-followers",
            "metadata": [
              {
                "annotations": null,
                "generate_name": "",
                "generation": 1,
                "labels": {
                  "app.kubernetes.io/component": "unsealing",
                  "app.kubernetes.io/managed-by": "terraform",
                  "app.kubernetes.io/name": "vault-unseal",
                  "app.kubernetes.io/part-of": "vault"
                },
                "name": "vault-unseal-followers",
                "namespace": "vault",
                "resource_version": "220449",
                "uid": "d3db5fa0-c5c4-4d6e-a4f5-b97447407e9d"
              }
            ],
            "spec": [
              {
                "active_deadline_seconds": 0,
                "backoff_limit": 3,
                "backoff_limit_per_index": 0,
                "completion_mode": "NonIndexed",
                "completions": 1,
                "manual_selector": false,
                "max_failed_indexes": 0,
                "parallelism": 1,
                "pod_failure_policy": [],
                "selector": [
                  {
                    "match_expressions": null,
                    "match_labels": null
                  }
                ],
                "template": [
                  {
                    "metadata": [
                      {
                        "annotations": null,
                        "generate_name": "",
                        "generation": 0,
                        "labels": {
                          "app.kubernetes.io/component": "unsealing",
                          "app.kubernetes.io/name": "vault-unseal",
                          "app.kubernetes.io/part-of": "vault"
                        },
                        "name": "",
                        "resource_version": "",
                        "uid": ""
                      }
                    ],
                    "spec": [
                      {
                        "active_deadline_seconds": 0,
                        "affinity": [],
                        "automount_service_account_token": true,
                        "container": [
                          {
                            "args": [
                              "set -e\n\n# Install dependencies\necho \"Installing dependencies...\"\napk add --no-cache bash jq\n\n# Configure kubectl for in-cluster access\necho \"Configuring kubectl...\"\nkubectl config set-cluster kubernetes \\\n  --server=https://kubernetes.default.svc \\\n  --certificate-authority=/var/run/secrets/kubernetes.io/serviceaccount/ca.crt\n\nkubectl config set-credentials serviceaccount \\\n  --token=$(cat /var/run/secrets/kubernetes.io/serviceaccount/token)\n\nkubectl config set-context default \\\n  --cluster=kubernetes \\\n  --user=serviceaccount \\\n  --namespace=vault\n\nkubectl config use-context default\n\n# Verify kubectl connectivity\necho \"Verifying kubectl connectivity...\"\nkubectl version --client\n\n# Run the unseal script\necho \"Starting follower node unsealing and joining...\"\nbash /scripts/unseal-vault.sh\n"
                            ],
                            "command": [
                              "/bin/sh",
                              "-c"
                            ],
                            "env": [
                              {
                                "name": "VAULT_NAMESPACE",
                                "value": "vault",
                                "value_from": []
                              },
                              {
                                "name": "VAULT_RELEASE",
                                "value": "vault",
                                "value_from": []
                              },
                              {
                                "name": "VAULT_SECRET_NAME",
                                "value": "vault-unseal-keys",
                                "value_from": []
                              },
                              {
                                "name": "VAULT_KEY_THRESHOLD",
                                "value": "3",
                                "value_from": []
                              },
                              {
                                "name": "MAX_RETRY_ATTEMPTS",
                                "value": "5",
                                "value_from": []
                              },
                              {
                                "name": "POD_WAIT_TIMEOUT",
                                "value": "120",
                                "value_from": []
                              },
                              {
                                "name": "DEBUG",
                                "value": "false",
                                "value_from": []
                              }
                            ],
                            "env_from": [],
                            "image": "alpine/k8s:1.31.1",
                            "image_pull_policy": "IfNotPresent",
                            "lifecycle": [],
                            "liveness_probe": [],
                            "name": "vault-unsealer",
                            "port": [],
                            "readiness_probe": [],
                            "resources": [
                              {
                                "limits": {
                                  "cpu": "250m",
                                  "memory": "256Mi"
                                },
                                "requests": {
                                  "cpu": "100m",
                                  "memory": "128Mi"
                                }
                              }
                            ],
                            "security_context": [],
                            "startup_probe": [],
                            "stdin": false,
                            "stdin_once": false,
                            "termination_message_path": "/dev/termination-log",
                            "termination_message_policy": "File",
                            "tty": false,
                            "volume_device": [],
                            "volume_mount": [
                              {
                                "mount_path": "/scripts",
                                "mount_propagation": "None",
                                "name": "scripts",
                                "read_only": true,
                                "sub_path": "",
                                "sub_path_expr": ""
                              }
                            ],
                            "working_dir": ""
                          }
                        ],
                        "dns_config": [],
                        "dns_policy": "ClusterFirst",
                        "enable_service_links": true,
                        "host_aliases": [],
                        "host_ipc": false,
                        "host_network": false,
                        "host_pid": false,
                        "hostname": "",
                        "image_pull_secrets": [],
                        "init_container": [
                          {
                            "args": [
                              "set -e\n\n# Install jq for JSON parsing\nif ! command -v jq \u0026\u003e /dev/null; then\n  echo \"Installing jq...\"\n  apk add --no-cache jq\nfi\n\n# Wait for initialization secret to exist\necho \"Waiting for vault initialization to complete...\"\nMAX_WAIT=300\nELAPSED=0\nwhile ! kubectl get secret vault-unseal-keys -n vault \u0026\u003e/dev/null; do\n  if [ $ELAPSED -ge $MAX_WAIT ]; then\n    echo \"ERROR: Timeout waiting for initialization secret\"\n    exit 1\n  fi\n  echo \"Waiting for vault-unseal-keys secret... ($ELAPSED/$MAX_WAIT seconds)\"\n  sleep 5\n  ELAPSED=$((ELAPSED + 5))\ndone\necho \"Initialization secret found\"\n\n# Wait for vault-0 to be unsealed\necho \"Waiting for vault-0 to be unsealed...\"\nELAPSED=0\nwhile true; do\n  if [ $ELAPSED -ge $MAX_WAIT ]; then\n    echo \"ERROR: Timeout waiting for vault-0 to unseal\"\n    exit 1\n  fi\n\n  STATUS=$(kubectl exec -n vault vault-0 -- vault status -format=json 2\u003e/dev/null | jq -r '.sealed' || echo \"true\")\n  if [[ \"$STATUS\" == \"false\" ]]; then\n    echo \"vault-0 is unsealed and ready\"\n    break\n  fi\n  echo \"Waiting for vault-0 to be unsealed... ($ELAPSED/$MAX_WAIT seconds)\"\n  sleep 5\n  ELAPSED=$((ELAPSED + 5))\ndone\n\n# Give vault-0 a moment to stabilize\necho \"Waiting for cluster stabilization...\"\nsleep 10\necho \"Ready to unseal follower nodes\"\n"
                            ],
                            "command": [
                              "/bin/sh",
                              "-c"
                            ],
                            "env": [],
                            "env_from": [],
                            "image": "alpine/k8s:1.31.1",
                            "image_pull_policy": "IfNotPresent",
                            "lifecycle": [],
                            "liveness_probe": [],
                            "name": "wait-for-init",
                            "port": [],
                            "readiness_probe": [],
                            "resources": [
                              {
                                "limits": {},
                                "requests": {}
                              }
                            ],
                            "security_context": [],
                            "startup_probe": [],
                            "stdin": false,
                            "stdin_once": false,
                            "termination_message_path": "/dev/termination-log",
                            "termination_message_policy": "File",
                            "tty": false,
                            "volume_device": [],
                            "volume_mount": [],
                            "working_dir": ""
                          }
                        ],
                        "node_name": "",
                        "node_selector": null,
                        "os": [],
                        "priority_class_name": "",
                        "readiness_gate": [],
                        "restart_policy": "OnFailure",
                        "runtime_class_name": "",
                        "scheduler_name": "default-scheduler",
                        "security_context": [],
                        "service_account_name": "vault-init",
                        "share_process_namespace": false,
                        "subdomain": "",
                        "termination_grace_period_seconds": 30,
                        "toleration": [],
                        "topology_spread_constraint": [],
                        "volume": [
                          {
                            "aws_elastic_block_store": [],
                            "azure_disk": [],
                            "azure_file": [],
                            "ceph_fs": [],
                            "cinder": [],
                            "config_map": [
                              {
                                "default_mode": "0755",
                                "items": [],
                                "name": "vault-init-scripts",
                                "optional": false
                              }
                            ],
                            "csi": [],
                            "downward_api": [],
                            "empty_dir": [],
                            "ephemeral": [],
                            "fc": [],
                            "flex_volume": [],
                            "flocker": [],
                            "gce_persistent_disk": [],
                            "git_repo": [],
                            "glusterfs": [],
                            "host_path": [],
                            "iscsi": [],
                            "local": [],
                            "name": "scripts",
                            "nfs": [],
                            "persistent_volume_claim": [],
                            "photon_persistent_disk": [],
                            "projected": [],
                            "quobyte": [],
                            "rbd": [],
                            "secret": [],
                            "vsphere_volume": []
                          }
                        ]
                      }
                    ]
                  }
                ],
                "ttl_seconds_after_finished": "300"
              }
            ],
            "timeouts": {
              "create": "10m",
              "delete": null,
              "update": "10m"
            },
            "wait_for_completion": false
          },
          "sensitive_attributes": [],
          "identity_schema_version": 1,
          "identity": {
            "api_version": "batch/v1",
            "kind": "Job",
            "name": "vault-unseal-followers",
            "namespace": "vault"
          },
          "private": "eyJlMmJmYjczMC1lY2FhLTExZTYtOGY4OC0zNDM2M2JjN2M0YzAiOnsiY3JlYXRlIjo2MDAwMDAwMDAwMDAsImRlbGV0ZSI6NjAwMDAwMDAwMDAsInVwZGF0ZSI6NjAwMDAwMDAwMDAwfSwic2NoZW1hX3ZlcnNpb24iOiIxIn0=",
          "dependencies": [
            "helm_release.vault",
            "kubernetes_config_map.vault_init_scripts",
            "kubernetes_job_v1.vault_init",
            "kubernetes_namespace.vault",
            "kubernetes_role.vault_init",
            "kubernetes_role_binding.vault_init",
            "kubernetes_service_account.vault_init"
          ]
        }
      ]
    },
    {
      "mode": "managed",
      "type": "kubernetes_namespace",
      "name": "vault",
      "provider": "provider[\"registry.terraform.io/hashicorp/kubernetes\"]",
      "instances": [
        {
          "index_key": 0,
          "schema_version": 0,
          "attributes": {
            "id": "vault",
            "metadata": [
              {
                "annotations": null,
                "generate_name": "",
                "generation": 0,
                "labels": {
                  "app.kubernetes.io/component": "server",
                  "app.kubernetes.io/name": "vault",
                  "name": "vault"
                },
                "name": "vault",
                "resource_version": "220204",
                "uid": "54653b94-9726-4434-ab41-afc92ae5f304"
              }
            ],
            "timeouts": null,
            "wait_for_default_service_account": false
          },
          "sensitive_attributes": [],
          "identity_schema_version": 1,
          "identity": {
            "api_version": "v1",
            "kind": "Namespace",
            "name": "vault"
          },
          "private": "eyJlMmJmYjczMC1lY2FhLTExZTYtOGY4OC0zNDM2M2JjN2M0YzAiOnsiZGVsZXRlIjozMDAwMDAwMDAwMDB9fQ=="
        }
      ]
    },
    {
      "mode": "managed",
      "type": "kubernetes_role",
      "name": "vault_init",
      "provider": "provider[\"registry.terraform.io/hashicorp/kubernetes\"]",
      "instances": [
        {
          "index_key": 0,
          "schema_version": 0,
          "attributes": {
            "id": "vault/vault-init",
            "metadata": [
              {
                "annotations": null,
                "generate_name": "",
                "generation": 0,
                "labels": {
                  "app.kubernetes.io/component": "initialization",
                  "app.kubernetes.io/managed-by": "terraform",
                  "app.kubernetes.io/name": "vault-init",
                  "app.kubernetes.io/part-of": "vault"
                },
                "name": "vault-init",
                "namespace": "vault",
                "resource_version": "220208",
                "uid": "6600975d-9f33-4241-aa4a-0c1912d3f713"
              }
            ],
            "rule": [
              {
                "api_groups": [
                  ""
                ],
                "resource_names": null,
                "resources": [
                  "pods/exec"
                ],
                "verbs": [
                  "create",
                  "get"
                ]
              },
              {
                "api_groups": [
                  ""
                ],
                "resource_names": null,
                "resources": [
                  "pods"
                ],
                "verbs": [
                  "get",
                  "list",
                  "watch"
                ]
              },
              {
                "api_groups": [
                  "apps"
                ],
                "resource_names": null,
                "resources": [
                  "statefulsets"
                ],
                "verbs": [
                  "get"
                ]
              },
              {
                "api_groups": [
                  ""
                ],
                "resource_names": [
                  "vault-unseal-keys"
                ],
                "resources": [
                  "secrets"
                ],
                "verbs": [
                  "get",
                  "patch",
                  "update"
                ]
              },
              {
                "api_groups": [
                  ""
                ],
                "resource_names": null,
                "resources": [
                  "secrets"
                ],
                "verbs": [
                  "create"
                ]
              },
              {
                "api_groups": [
                  ""
                ],
                "resource_names": null,
                "resources": [
                  "configmaps"
                ],
                "verbs": [
                  "create",
                  "get"
                ]
              }
            ]
          },
          "sensitive_attributes": [],
          "identity_schema_version": 1,
          "identity": {
            "api_version": "rbac.authorization.k8s.io/v1",
            "kind": "Role",
            "name": "vault-init",
            "namespace": "vault"
          },
          "private": "bnVsbA==",
          "dependencies": [
            "kubernetes_namespace.vault"
          ]
        }
      ]
    },
    {
      "mode": "managed",
      "type": "kubernetes_role_binding",
      "name": "vault_init",
      "provider": "provider[\"registry.terraform.io/hashicorp/kubernetes\"]",
      "instances": [
        {
          "index_key": 0,
          "schema_version": 0,
          "attributes": {
            "id": "vault/vault-init",
            "metadata": [
              {
                "annotations": null,
                "generate_name": "",
                "generation": 0,
                "labels": {
                  "app.kubernetes.io/component": "initialization",
                  "app.kubernetes.io/managed-by": "terraform",
                  "app.kubernetes.io/name": "vault-init",
                  "app.kubernetes.io/part-of": "vault"
                },
                "name": "vault-init",
                "namespace": "vault",
                "resource_version": "220210",
                "uid": "fb746a8d-cce2-44b3-ba92-55995dc0a4e4"
              }
            ],
            "role_ref": [
              {
                "api_group": "rbac.authorization.k8s.io",
                "kind": "Role",
                "name": "vault-init"
              }
            ],
            "subject": [
              {
                "api_group": "",
                "kind": "ServiceAccount",
                "name": "vault-init",
                "namespace": "vault"
              }
            ]
          },
          "sensitive_attributes": [],
          "identity_schema_version": 1,
          "identity": {
            "api_version": "rbac.authorization.k8s.io/v1",
            "kind": "RoleBinding",
            "name": "vault-init",
            "namespace": "vault"
          },
          "private": "bnVsbA==",
          "dependencies": [
            "kubernetes_namespace.vault",
            "kubernetes_role.vault_init",
            "kubernetes_service_account.vault_init"
          ]
        }
      ]
    },
    {
      "mode": "managed",
      "type": "kubernetes_service_account",
      "name": "vault_init",
      "provider": "provider[\"registry.terraform.io/hashicorp/kubernetes\"]",
      "instances": [
        {
          "index_key": 0,
          "schema_version": 0,
          "attributes": {
            "automount_service_account_token": true,
            "default_secret_name": "",
            "id": "vault/vault-init",
            "image_pull_secret": [],
            "metadata": [
              {
                "annotations": null,
                "generate_name": "",
                "generation": 0,
                "labels": {
                  "app.kubernetes.io/component": "initialization",
                  "app.kubernetes.io/managed-by": "terraform",
                  "app.kubernetes.io/name": "vault-init",
                  "app.kubernetes.io/part-of": "vault"
                },
                "name": "vault-init",
                "namespace": "vault",
                "resource_version": "220207",
                "uid": "c3ac82ff-0c54-4eb4-94c2-18d6d7c196c1"
              }
            ],
            "secret": [],
            "timeouts": null
          },
          "sensitive_attributes": [],
          "identity_schema_version": 1,
          "identity": {
            "api_version": "v1",
            "kind": "ServiceAccount",
            "name": "vault-init",
            "namespace": "vault"
          },
          "private": "eyJlMmJmYjczMC1lY2FhLTExZTYtOGY4OC0zNDM2M2JjN2M0YzAiOnsiY3JlYXRlIjozMDAwMDAwMDAwMH19",
          "dependencies": [
            "kubernetes_namespace.vault"
          ]
        }
      ]
    }
  ],
  "check_results": [
    {
      "object_kind": "var",
      "config_addr": "var.init_key_threshold",
      "status": "pass",
      "objects": [
        {
          "object_addr": "var.init_key_threshold",
          "status": "pass"
        }
      ]
    },
    {
      "object_kind": "var",
      "config_addr": "var.log_level",
      "status": "pass",
      "objects": [
        {
          "object_addr": "var.log_level",
          "status": "pass"
        }
      ]
    },
    {
      "object_kind": "var",
      "config_addr": "var.init_key_shares",
      "status": "pass",
      "objects": [
        {
          "object_addr": "var.init_key_shares",
          "status": "pass"
        }
      ]
    },
    {
      "object_kind": "var",
      "config_addr": "var.replicas",
      "status": "pass",
      "objects": [
        {
          "object_addr": "var.replicas",
          "status": "pass"
        }
      ]
    },
    {
      "object_kind": "var",
      "config_addr": "var.log_format",
      "status": "pass",
      "objects": [
        {
          "object_addr": "var.log_format",
          "status": "pass"
        }
      ]
    },
    {
      "object_kind": "var",
      "config_addr": "var.init_job_cleanup_seconds",
      "status": "pass",
      "objects": [
        {
          "object_addr": "var.init_job_cleanup_seconds",
          "status": "pass"
        }
      ]
    }
  ]
}
